{"version":3,"sources":["main.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"source-deps.js","sourcesContent":["(function () {\n  'use strict';\n\n  var wrench = require('wrench'),\n      path = require('path'),\n      fs = require('fs'),\n      colors = require('colors'),\n      _log = function () {\n        arguments[0] = '[' + colors.grey('SOURCE DEPS') + '] ' + arguments[0];\n        console.log.apply(this, arguments);\n      };\n\n  colors.setTheme({\n    info: 'cyan',\n    warn: 'yellow',\n    error: 'red',\n    success: 'green'\n  });\n\n  function _mergeObjects (o1, o2) {\n    var k, v;\n    for (k in o2) {\n      v = o2[k];\n      o1[k] = v;\n    }\n    return o1;\n  }\n\n  function _packagers () {\n    return {\n      bower: {\n        jsonFile: 'bower.json',\n        pkgDir: 'bower_components'\n      },\n      npm: {\n        jsonFile: 'package.json',\n        pkgDir: 'node_modules'\n      }\n    };\n  }\n\n  function _isArray (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }\n\n  function _pullDependencies (jsonFile, opts) {\n    var deps = jsonFile.dependencies || {},\n        pkgList = [],\n        current;\n\n    if (opts.includeDevPackages) {\n      deps = _mergeObjects(deps, jsonFile.devDependencies || {});\n    }\n    \n    for (current in deps) {\n      if (opts.ignore.indexOf(current) == -1) {\n        pkgList.push(current);\n      } else {\n        _log('Ignoring '.success + colors.info(current));\n      }\n    }\n    \n    return pkgList;\n  }\n\n  function _guessDistFiles (pkgDir, pkg) {\n    var testPatterns = [\n          new RegExp(pkg + '.min.js$'),\n          new RegExp(pkg + '.js$')\n        ],\n        matches = [],\n        files = wrench.readdirSyncRecursive(path.join(pkgDir, pkg));\n\n    files.forEach(function (filename, idx1, arr1) {\n      testPatterns.forEach(function (pattern, idx2, arr2) {\n        if (filename.match(pattern)) {\n          matches[idx2] = filename;\n        }\n      });\n    });\n\n    return matches.filter(function (m) { return typeof(m) !== 'undefined'; }).shift();\n  }\n\n  function _resolveMains (pkgList, pkgDir, pkgrFileName, pkgrDefaultMain, overrides, done) {\n    var _check = function (p, pkg) {\n          if (!fs.existsSync(p)) {\n            _log('Package '.warn + colors.info(pkg) + ' file at '.warn + colors.info(p) + ' does not exist.'.warn);\n            return false;\n          }\n          return true;\n        },\n        _expand = function (p, pkg) {\n          p = path.resolve(pkgDir, pkg, p);\n          return p;\n        },\n        _process = function (pkg) {\n          var filepaths = overrides[pkg] || _guessDistFiles(pkgDir, pkg),\n              _processPath = function (path) {\n                path = _expand(path, pkg);\n                if (_check(path, pkg)) {\n                  return path;\n                }\n                return false;\n              };\n\n          if (_isArray(filepaths)) {\n            filepaths = filepaths.map(_processPath).filter(function (path) { return !!path; });\n          } else if (filepaths) {\n            filepaths = _processPath(filepaths);\n          }\n\n          if (!filepaths || (_isArray(filepaths) && filepaths.length === 0)) {\n            _log('Package '.warn + colors.info(pkg) + ' has no valid paths. Recommend override.'.warn);\n            filepaths = undefined;\n          }\n\n          return filepaths;\n        },\n        paths = {};\n\n    pkgList.forEach(function (element, idx, arr) {\n      if (paths.hasOwnProperty(element)) {\n        return;\n      }\n      paths[element] = _process(element);\n    });\n\n    return paths;\n  }\n\n  function _scanPkgr (pkgr, opts) {\n    var pkgrEntry = _packagers()[pkgr],\n        pkgList = [],\n        resolved = {},\n        jsonPath,\n        pkgDirPath;\n    \n    if (!pkgrEntry) {\n      throw new Error('Packager '.error + colors.info(pkgr) + ' not supported.'.error);\n    }\n\n    jsonPath = path.join(opts.rootDir, pkgrEntry.jsonFile);\n\n    if (!fs.existsSync(jsonPath)) {\n      throw new Error('Packager '.error + colors.info(pkgr) + ' missing JSON file '.error + colors.info(pkgrEntry.jsonFile) + ' @ '.error + colors.info(jsonPath));\n    }\n\n    pkgDirPath = path.join(opts.rootDir, pkgrEntry.pkgDir);\n\n    if (!fs.existsSync(pkgDirPath)) {\n      throw new Error('Packager '.error + colors.info(pkgr) + ' missing package directory '.error + colors.info(pkgrEntry.pkgDir) + ' @ '.error + colors.info(pkgDirPath));\n    }\n\n    pkgList = _pullDependencies(require(jsonPath), opts);\n\n    if (opts.include) {\n      pkgList = pkgList.concat(opts.include);\n    }\n\n    if (opts.secondaryDeps) {\n      (function (pkgList, entry, opts) {\n        var pLen = pkgList.length,\n            pCur,\n            jPath,\n            secDeps;\n\n        while (pLen--) {\n          pCur = pkgList[pLen];\n          jPath = path.join(opts.rootDir, entry.pkgDir, pCur, entry.jsonFile);\n          secDeps = _pullDependencies(require(jPath), opts);\n          Array.prototype.splice.apply(pkgList, [pLen, 0].concat(secDeps));\n        }\n      })(pkgList, pkgrEntry, opts);\n    }\n\n    resolved = _resolveMains(\n      pkgList,\n      pkgDirPath,\n      pkgrEntry.jsonFile,\n      pkgrEntry.defaultMain,\n      opts.overrides\n    );\n\n    return resolved;\n  }\n\n  module.exports = function (opts) {\n    var settings = {\n          packagers: ['npm', 'bower'],\n          overrides: {},\n          includeDevPackages: false,\n          secondaryDeps: false,\n          logOutput: false,\n          rootDir: process.cwd(),\n          order: [],\n          ignore: [],\n          include: []\n        },\n        pathList = [],\n        mains = {},\n        addPkg = function (pkg, idx) {\n          var path;\n\n          path = mains[pkg];\n          if (!path) {\n            return;\n          }\n\n          if (idx) {\n            Array.prototype.splice.apply(pathList, [idx, 0].concat(path));\n            return;\n          }\n\n          if (_isArray(path)) {\n            pathList = pathList.concat(path);\n            return;\n          }\n          pathList.push(path);\n        },\n        currentPkg;\n\n    opts = _mergeObjects(settings, opts);\n    opts.rootDir = path.resolve(opts.rootDir);\n\n    if (!opts.logOutput) {\n      _log = function () {};\n    }\n\n    opts.packagers.forEach(function (element, idx, array) {\n      mains = _mergeObjects(mains, _scanPkgr(element, opts));\n    });\n    \n    opts.order.forEach(function (pkg, idx, array) {\n      addPkg(pkg, idx);\n      delete mains[pkg];\n    });\n\n    for (currentPkg in mains) {\n      addPkg(currentPkg);\n    }\n    \n    _log('Loaded '.success + colors.info(pathList.length) + ' dependent files.'.success);\n\n    return pathList;\n  };\n})();"],"sourceRoot":"/source/"}